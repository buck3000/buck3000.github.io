# A Beginners Introduction to Ractors in Ruby with Real-World Examples
Ruby 3.0 introduced an exciting new feature called Ractors (Ruby Actors) aimed at making true parallel execution possible in Ruby. For those working in complex applications, this feature has been a much-awaited addition - and today after watching a script run for more than 24 hours, I decided I wanted to learn more about them.

## What Are Ractors?
Ractors are a concurrency abstraction designed to provide a parallel execution feature in Ruby. Before Ractors, the Global Interpreter Lock (GIL) in Ruby made it difficult to utilize multiple cores for executing Ruby code in parallel. With Ractors, each Ractor runs in its isolated environment, allowing for true parallel computation.

## A Simple Example
Here's a hello world basic example to demonstrate how Ractors work:

```
ractor = Ractor.new do
  "Hello World from a Ractor"
end

puts ractor.take  # Output: "Hello from a Ractor"
```

## Parallelizing a Ruby Script
Let's take an example of pushing code to multiple Git repositories. The naive way to do this is using a loop, but this isn't efficient.

```
fwc_apps = ["repo1", "repo2", ...]

fwc_apps.each do |app|
  puts "pushing to the #{app} remote..."
  `git push #{app} master`
end
Using Ractors for Parallel Execution
Now let's parallelize this code using Ractors.

ruby
Copy code
fwc_apps = ["repo1", "repo2", ...]

# Create a Ractor for each app
ractors = fwc_apps.map do |app|
  Ractor.new(app) do |my_app|
    puts "pushing to the #{my_app} remote..."
    `git push #{my_app} master`
  end
end

# Wait for all Ractors to finish their execution
ractors.each(&:take)
```

## Optimal Number of Ractors
If your machine has 12 cores, using all of them for Ractors might not be a good idea since you'll need some for other tasks. It's often better to leave a couple of cores for the system. So, in a 12-core system, you might consider using 10 Ractors.

Find the number of cores on your Mac:
```sysctl -n hw.ncpu```

## Advanced Example: Using Channels and Error Handling
Here's a more advanced example, incorporating error handling and a dynamic pool size for Ractors.

```
fwc_apps = ["repo1", "repo2", ...]
POOL_SIZE = 10

task_channel = Ractor::Channel.new
error_channel = Ractor::Channel.new

fwc_apps.each { |app| task_channel.send(app) }

ractors = []

POOL_SIZE.times do
  ractors << Ractor.new(task_channel, error_channel) do |task_ch, error_ch|
    while (app = task_ch.take)
      begin
        puts "pushing to the #{app} remote..."
        `git push #{app} master`
      rescue => e
        error_ch.send([app, e.message])
      end
    end
  end
end

POOL_SIZE.times { task_channel.send(nil) }
ractors.each(&:take)

errors = []
while error_channel.empty? == false
  errors << error_channel.take
end

unless errors.empty?
  puts "The following errors occurred:"
  errors.each { |app, error| puts "#{app}: #{error}" }
end
```

## Conclusion
Ractors provide a way to achieve real parallel execution in Ruby, which was a bottleneck for many multi-core operations. Although they add complexity, the performance gains are worth it for CPU-bound tasks.
